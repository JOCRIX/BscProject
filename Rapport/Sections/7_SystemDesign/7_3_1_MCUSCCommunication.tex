\subsection{MCU and Sample Control communication} \label{subsec:MCUSCCommunication} 
This section will focus on how the main processing unit implements and handles the communication protocol with the sample control module. 
The protocol designed for communication between the main processing unit and the Sample Control Unit has previously been described in section \refq{subsec:Communication}.

C is not an object oriented language, the principle of objects is however the focal point of the implementation of the communication code. This is implemented through the struct CommPort of the designated data-type CommunicationPort. This data-type holds 3 main elements, control, set and get, respectivly refered to as ctrl, set and get. This can be seen in listing \refq{lst:7_3_1_StructCommPort}.

\lstinputlisting[language=c ,style = c,firstnumber=1, linerange=175-202, caption={The CommPort struct of the CommunicationPort data-type used to control the communication port with the Sample Control Module.}, label={lst:7_3_1_StructCommPort}]{Appendix/Code/main_2612.tex}

These 3 elements are used to control the pins, ports etc. that the port is physically connected to. This can be used to set up the hardware. Set is used to set the port, such as setting an output value on the port, configuring it as inputs etc. Get is the general struct that will be used, as it utilizes call-back functions using the struct Set and Control. In this way, the hardware must be set up once, hereafter the port can be completely controlled by the Get struct call-back functions. 

Pointers and call-back functions have been extensively used in the CommPort struct. This has been a point of focus, as it makes it very intuitive and easy for the programmer to set up a register on the Sample Control Module. For example, if one wishes to set up the Sample Control Module for a total sample size of 10000, one would simply have to first set the IX-pin for internal, and then send the value 10000 to register 6. This can be done by using the CommPort struct as:

\begin{itemize}
    \item CommPort.set.SetIXMode(INTERNAL);
    \item CommPort.WriteData(10000, 6);
\end{itemize}

SetIXMode() callback then calls the other, required, callbacks inside the struct for setting up the IX pin for internal registers, setting the port to an output, sending the address first and then the data for the address. Note that INTERNAL here belongs to an enum with, INTERNAL = 0 and EXTERNAL = 1. In this way one does not have to keep track of the ones and zeros, but rather the functionality instead.

To fully describe the system, the handling of the protocol will be described in more detail specifically for the Control part, Set part and Get part. Not all functions will be described here, only those that are key for the opperation, as many are very similar.

\subsubsection{Control}
In order for the call-back functions to function, all the hardware must be specified to the CommPort struct. This is done through the Control data-type in listing \refq{lst:7_3_1_StructCommPort}. The specific pins can be found in appendix \refq{App:PinMap_MCU_FPGA}, the setup of these pins can be seen in listing \refq{lst:7_3_1_CommPort_PinSetup}, note that line 1 indicates that it points to its own address, allowing the struct to access data inside the struct itself.

\lstinputlisting[language=c ,style = c,firstnumber=1, linerange=1619-1643, caption={Pin setup for the CommPort struct.}, label={lst:7_3_1_CommPort_PinSetup}]{Appendix/Code/main_2612.tex}

This way of setting up the port makes it very easy to change pins or swap processor if needed. Here the used pins need only be reconfigured in the setup of the struct. This also comes in handy when opperating with an ARM processor such as the STM32F446RE. When writing to or reading from a pin, once must both specify the pin and the specific port of that pin. The task of keeping track of the port of each pin quickly becomes a dreary one, this is simply avoided by the given implementation.

\subsubsection{Set}
The Set struct of the CommunicationPort data-type is a collection of call-back functions specifically used for setting up the port. The different options within this struct are as in line 14 to 20 in listing \refq{lst:7_3_1_CommPort_PinSetup}.

Notice that many of these call-back functions takes in enumerators as inputs, these simply act as a way for the human programmer to keep track of the ones and zeros. The IXMode enum can take either the value INTERNAL = 0 or EXTENRAL = 1. It is however much easier to keep track of the functionality than it is to keep track of a zero and one. Thus if it is desired to set the IX pin to internal, one would simply call the function as $CommPort.Set.SetIOMode(INTERNAL)$, the compiler will then take care of inserting a '0' instead of the text INTERNAL. 

All these functions return an 8 bit signed integer, this is a status variable, if the function is executed as expected the return value will be a 1, if the hardware in the ctrl struct have not been set-up such that the CommPort.ctrl.selfAddr is a null pointer, all functions will return a -1. This is done, as operating on a null pointer will cause the System to crash, so, the pointer is sanity checked before being used. If it is a null pointer, the function is not executed and an error flag is returned.

All functions in the set struct are call-back functions, the specifc functions that these point to can be seen in listing \refq{lst:7_3_1_CommPort_setPointers}.
\lstinputlisting[language=c ,style = c,firstnumber=1, linerange=1609-1615, caption={Directing the call-back functions to the specific funtion that they should carry out when called upon.}, label={lst:7_3_1_CommPort_setPointers}]{Appendix/Code/main_2612.tex}

The \textbf{SetGPIOMode} function can be seen in listing \refq{lst:7_3_1_SetIOMode}. This function configures the port for either an input or output. The port consists of 16 pins, pins 0-7 on port B and pins 0-7 on port C of the STM32F446RE.
\lstinputlisting[language=c ,style = c,firstnumber=1, linerange=1234-1282, caption={Code for the SetGPIOMode function used to set a value on the 16 bit wide port connection the MCU and Sample Control Module together.}, label={lst:7_3_1_SetIOMode}]{Appendix/Code/main_2612.tex}

The enumerator \textbf{enum IOMode} is used for input of the function can either take the value READ or WRITE. The \textbf{static GPIO\_InitTypeDef} in line 4 and 5 is an STM32 struct used to set up the hardware of a pin/port. It configures the port mode, speed and if pullup or pulldown resistors should be used.

The function essentially works by loading in the configured hardware from the ctrl struct, line 3, if the function is then called for configure the port for READ mode i.e. an input, it then load in the specific hardware pins to the HighByte and LowByte struct by a loop, line 10 to 14. With all the pins loaded in to the STM32 struct, GPIO\_InitTypeDef, for the high and low byte, the port is simply configured for an input, line 18 and 19, for pull-up resistors, line 20 and 21, and the current mode variable in the ctrl struct is updated to indicate that the port is in READ mode, line 22. The port is confiugred in exactly the same way for an WRITE mode, except that here the mode is set for an open drain output

The physcical port is then updated in line 43 and 44 by the function \textbf{HAL\_GPIO\_Init}. This is once again an STM32 specific function that updates the specific microcontroller registers in order to configure the microcontroller for the specified port settings.

%Comm port code etc